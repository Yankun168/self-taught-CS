# 线程（Thread）概述

今天我们会讨论线程以及xv6如何实现线程切换。

首先， 为什么需要多线程？

- 人们希望他的计算机在同一时间不只是执行一个任务。 我们希望计算机能够分时复用。在同一时间完成多个任务。
- 多线程能够将代码变得更简单。线程在有些场合可以帮助程序员将代码以简单优雅的方式进行组织，并减少复杂度。
- 多线程能够实现并行运算。在拥有多个CPU的计算机上获得更快的运行速度。 常见方式是将程序进行拆分，并通过在不同的CPU核上运行不同的部分代码。

线程可以看做是在右多个任务时简化编程的抽象。 一个线程可以认为是串行执行的代码。 如果一个程序按顺序执行代码，那么你可以把它看成是单线程程序。 人们对于线程的定义有很多，在这里我们认为线程就是单个串行执行代码的单元，它只占用一个CPU，按顺序执行代码。

线程还有自己的状态，我们可以随时保存线程的状态并暂停线程的运行，并在之后通过恢复状态来恢复线程的执行。 线程的状态包括以下三方面：

1. PC，程序计数器，表示当前线程执行指令的位置
2. register，保存变量的寄存器
3. stack，记录函数的调用，反应当前线程的执行点。

操作系统中线程系统的工作就是管理多个线程的运行。我可能会启动成百上千个线程，而线程系统的工作就是搞清楚他们的关系并让他们都能正常运行。

多线程的并行运行主要有两个策略：

- 使用多核CPU，每个CPU运行一个线程。
- 一个CPU在多个线程间切换。

现实情况是，我们会有成百上千个线程，但是只有几个CPU，因此第二种情况会更常见一些。我们也会主要关注于这种情况。

不同线程系统之间的一个主要区别就是，线程之间是否会共享内存？

一种可能是你有一块地址空间，多个线程在这块空间上运行，彼此能看到对方的更新。

这种情况下，有共享的空间，我们需要用到锁来保证程序的正确性。

xv6共享了内存，并且支持了内核线程的概念。对于每个进程，都有一个用户线程和内核线程。 用户线程完成进程的用户代码，而内核线程完成用户进程的系统调用。其中用户线程之间没有共享内存，因为每一个用户process都有独立的地址空间。而内核thread之间是共享内存的。

在一些更复杂的系统，例如linux，一个用户进程包含多个线程，多个线程之间共享进程的地址空间。

## **XV6线程调度**

实现内核中的线程调用有以下挑战：

如何实现线程间的切换。 这里停止一个线程并启动另外一个线程的行为称为调度（scheduling）。在xv6中，每一个CPU核都创建了一个scheduler完成调度工作。

当线程切换时，内核需要保存和恢复线程信息，你需要决定哪些线程信息是需要保存和回复的。

如何处理运算密集型线程（compute bound thread），compute bound thread指的是一个线程持续占用CPU资源，并且不会自愿释放对CPU的控制。 我们需要有一些策略来强制切换线程。 当一个线程执行一段时间并仍不打算释放CPU资源，内核就启用这种策略来切换线程。

接下来我们主要介绍如何处理compute bound thread。 方法是利用定时器中断。 在每个CPU上都存在一个硬件设备，它会定时产生中断。xv6和其他所有操作系统一样，将这个中断传到内核中。 所以当我们在计算π的前1000万位时，定时器能以10ms为周期发出中断，将程序运行的控制权从用户空间切换到内核的中断处理程序，哪怕这些用户空间进程不配合空座。

位于内核的定时器中断处理程序会自愿的让出CPU（yeild）给线程调度器（scheduler也有一个调度线程），并告诉线程调度器说，你可以让一些其他线程运行了。

在之前我们已经介绍了中断处理的流程。在这里基本的流程时定时器中断将CPU控制权交给内核，内核再自愿的出让CPU。

这里的处理流程称为pre-emptive scheduling。 pre-emptive的意思是就算用户线程不愿出让CPU，定时器中断任然会把CPU的控制权抢走。 与之相反的是voluntary scheduling。

在执行线程调度时，操作系统需要能区别以下几类线程：

- running：正在运行的线程
- runable：可以运行但还未运行的线程
- SLEEPING：不想运行的线程，因为这些线程可能在等待IO或其他事件。

今天主要关注前两种线程。之前介绍的pre-emptive scheduling就是将线程状态从running转变为runable。

## **XV6线程切换**

接下来我们会介绍线程切换是如何进行的。

我们会运行很多用户空间进程，例如C compiler（CC），LS, Shell。在用户空间，每个进程都有自己的内存，我们关心的是每个进程都包含了自己的user stack，并且进程运行时有自己的PC和Registers。 如果一个进程执行sys call或者因为中断走到了内核，那么相应的用户空间状态会被保存在程序的trapframe中。 同时属于这个程序的内核线程被激活（用于在内核空间中执行代码）。之后内核会进行一段时间处理sys call或中断。 处理完成后，如需要返回到用户空间，trapframe中保存的用户进程状态会被恢复。

而如果是因为定时器中断走到内核空间。上一节提到的pre-emptive scheduling切换线程。如果xv6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会切换到第二个程序的内核线程。之后再第二个进程的内核线程中从内核空间返回到用户空间，通过恢复trapframe完成。

当xv6从CC程序的内核线程切换的LS程序的内核线程时：

1. xv6首先会将CC程序的内核线程的内核寄存器保存在一个context对象中。
2. 类似的，因为需要切换到LS，LS此时势必是runable，它的用户空间状态被保存在trapframe中。xv6需要恢复ls程序的context对象，即恢复ls内核线程的寄存器信息等。
3. 之后ls会继续它在内核线程中完成的中断处理程序，（假设ls程序之前也是通过定时器中断进入的内核）
4. 恢复ls的用户空间状态，返回到用户空间。
5. 恢复执行ls

这里的核心是，在xv6中，进程间切换任何时候都需要经历：

1. 从用户进程进入它对应的内核线程（保存用户线程的状态）
2. 从第一个内核线程切换到另一个进程的内核线程。
3. 返回到第二个进程的用户线程（恢复用户线程状态）
4. 第二个进程执行

线程调度就发生在第二个过程中。

## XV6线程切换（二）

实际的线程切换流程会更复杂。相比之前，它并不直接将CPU资源交给第二个内核线程，而是交给scheduler线程。

 假设我们有两个进程P1,P2。 P1正在运行而P2是runable。假设在xv6中，有两个CPU，CPU0,CPU1.

我们从P1的用户线程切换到P2的用户线程的完整故事是：

首先，一个定时器中断强迫CPU从用户空间切换的内核，trampoline代码将用户寄存器保存于trapframe中。

之后在内核中运行usertrap进行中断处理，此时CPU正在p1的内核线程上，执行内核代码。

假设p1的内核线程决定它想让出CPU。它会做很多工作，最后调用swtch函数，这是线程切换的核心函数之一。

swtch会保存p1内核线程的寄存器信息与context对象中。 目前有两类寄存器：用户寄存器保存在trapframe中，内核线程的寄存器保存在context中。

但是swtch并不是直接从一个内核线程切换到另一个内核线程中。在xv6中，内核线程首先会切换到scheduler线程（恢复scheduler线程的context信息），在scheduler线程下完成切换到另一个线程的工作。

这里是通过scheduler函数完成。它会做一些清理工作，比如将p1状态设置为runable。再找到另外一个可执行线程，再次调用swtch函数，从scheduler线程切换到p2内核线程。

这里的具体步骤是：

1. 先保存自己的寄存器信息到scheduler线程的context对象中。

2. 找到要切换的线程p2的context信息，恢复它。
3. 因为p2在进入runable之前，必然也被定时器中断，调用了swtch，此时恢复到之前的swtch中，返回到p2的系统调用或者中断处理程序。

4. 最后p2从内核线程切换到用户线程，恢复在trapframe中保存的信息。p2就能继续运行了。

每个CPU都有自己的scheduler线程，它也是一种内核线程，有自己的context对象。任何线程切换都需要用到scheduler线程。

> 学生提问：context保存在哪？
>
> 答： 进程的内核线程的context保存在proc结构体中。 而scheduler线程的context保存在CPU结构体中。

> 学生提问：为什么不能将context对象保存在进程对应的trapframe中？
>
> Robert教授：context可以保存在trapframe中，因为每一个进程都只有一个内核线程对应的一组寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰的目的，trapframe还是只包含进入和离开内核时的数据。而context结构体中包含的是在内核线程和调度器线程之间切换时，需要保存和恢复的数据。
>
> 学生提问：出让CPU是由用户发起的还是由内核发起的？
>
> Robert教授：对于XV6来说，并不会直接让用户线程出让CPU或者完成线程切换，而是由内核在合适的时间点做决定。有的时候你可以猜到特定的系统调用会导致出让CPU，例如一个用户进程读取pipe，而它知道pipe中并不能读到任何数据，这时你可以预测读取会被阻塞，而内核在等待数据的过程中会运行其他的进程。
>
> 内核会在两个场景下出让CPU。当定时器中断触发了，内核总是会让当前进程出让CPU，因为我们需要在定时器中断间隔的时间点上交织执行所有想要运行的进程。另一种场景就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。
>
> 学生提问：用户进程调用sleep函数是不是会调用某个系统调用，然后将用户进程的信息保存在trapframe，然后触发进程切换，这时就不是定时器中断决定，而是用户进程自己决定了吧？
>
> Robert教授：如果进程执行了read系统调用，然后进入到了内核中。而read系统调用要求进程等待磁盘，这时系统调用代码会调用sleep，而sleep最后会调用swtch函数。swtch函数会保存内核线程的寄存器到进程的context中，然后切换到对应CPU的调度器线程，再让其他的线程运行。这样在当前线程等待磁盘读取结束时，其他线程还能运行。所以，这里的流程除了没有定时器中断，其他都一样，只是这里是因为一个系统调用需要等待I/O（注，感觉答非所问）
>
> 学生提问：每一个CPU的调度器线程有自己的栈吗？
>
> Robert教授：是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈和context，与用户进程不一样，都是在系统启动时就设置好了。如果你查看XV6的start.s文件，你就可以看到为每个CPU核设置好调度器线程。

这里有个术语需要解释。当人们在说context switching，他们通常说从一个线程切换到另一个线程。 因为这涉及到保存前一个线程的context，再恢复后一个线程的context。 有时context switching也指从一个用户进程切换到另一个用户进程，偶尔也指从用户空间切换到内核空间。

对于这节内容，context switching主要指内核线程和调度器线程之间的切换。

每个CPU在一个时间只会做一件事，运行一个线程。 要么是用户进程的线程，要么是内核线程，要么是scheduler线程。而多个线程之间的切换创造了多个线程运行在同一个CPU的假象。 

在xv6的代码中，context对象总是由swtch产生，所以context总是保存了内核线程在执行swtch时的状态，当恢复一个内核线程时，第一时间也是从swtch中返回。

> 学生提问：我们这里一直在说线程，但是从我看来XV6的实现中，一个进程就只有一个线程，有没有可能一个进程有多个线程？
>
> Robert教授：我们这里的用词的确有点让人混淆。在XV6中，一个进程要么在用户空间执行指令，要么是在内核空间执行指令，要么它的状态被保存在context和trapframe中，并且没有执行任何指令。这里该怎么称呼它呢？你可以根据自己的喜好来称呼它，对于我来说，每个进程有两个线程，一个用户空间线程，一个内核空间线程，并且存在限制使得一个进程要么运行在用户空间线程，要么为了执行系统调用或者响应中断而运行在内核空间线程 ，但是永远也不会两者同时运行。

## XV6进程切换示例程序

接下来会演示，在xv6中是如何完成进程切换的。

先来看看proc结构体的内容。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

它保存了一些很重要的东西，比如说procstate，进程状态，context，内核线程的context信息，和trapframe。

lock字保护了很多字段的更新，至少是state的更新。

接下来看一段程序，它会完成进程的切换。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

这个程序会创建两个进程，进入一个死循环。 两个都是compute bound process。为了让这两个进程都能运行，有必要让两个进程之间能互相切换。



接下来运行spin.c

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

可以看到两个进程都在同时运行，中断定时器在发挥作用。

这里是因为usertrap收到一个中断处理，调用devintr来处理中断，接下看在devintr中的207行设置一个断点，这一行会识别中断原因是定时器中断。

返回到usertrap后，我们希望运行到yield函数，

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

在yield函数中，当前进程会出让CPU让另一个进程运行。 现在我们看一下定时器中断发生时，用户空间进程正在执行什么内容。

可以打印一下当前进程的信息看看。

首先打印name：

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

是spin，如预期一样。

我们可以查看spin.asm文件来确定对应的地址指令。

查看trapframe中的内容，我们看看epc。epc保存了中断发生时的指令地址。

这里是0x62，在spin.asm中找到0x62，可以发现是死循环的部分。符合我们的预期。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

![img](https://files.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPnwhbNBmp_ySz6aCiz%2F-MPo2ysO4rjmXvb02jja%2Fimage.png?alt=media&token=df9df6f6-dc43-42d1-8f29-e3ff32c6c708)

> 学生提问：看起来所有的CPU核要能完成线程切换都需要有一个定时器中断，那如果硬件定时器出现故障了怎么办？
>
> Robert教授：是的，总是需要有一个定时器中断。用户进程的pre-emptive scheduling能工作的原因是，用户进程运行时，中断总是打开的。XV6会确保返回到用户空间时，中断是打开的。这意味着当代码在用户空间执行时，定时器中断总是能发生。在内核中会更加复杂点，因为内核中偶尔会关闭中断，比如当获取锁的时候，中断会被关闭，只有当锁被释放之后中断才会重新打开，所以如果内核中有一些bug导致内核关闭中断之后再也没有打开中断，同时内核中的代码永远也不会释放CPU，那么定时器中断不会发生。但是因为XV6是我们写的，所以它总是会重新打开中断。XV6中的代码如果关闭了中断，它要么过会会重新打开中断，然后内核中定时器中断可以发生并且我们可以从这个内核线程切换走，要么代码会返回到用户空间。我们相信XV6中不会有关闭中断然后还死循环的代码。
>
> 同一个学生提问：我的问题是，定时器中断是来自于某个硬件，如果硬件出现故障了呢？
>
> Robert教授：那你的电脑坏了，你要买个新电脑了。这个问题是可能发生的，因为电脑中有上亿的晶体管，有的时候电脑会有问题，但是这超出了内核的管理范围了。所以我们假设计算机可以正常工作。
>
> 有的时候软件会尝试弥补硬件的错误，比如通过网络传输packet，总是会带上checksum，这样如果某个网络设备故障导致某个bit反转了，可以通过checksum发现这个问题。但是对于计算机内部的问题，人们倾向于不用软件来尝试弥补硬件的错误。

> 学生提问：当一个线程结束执行了，比如说在用户空间通过exit系统调用结束线程，同时也会关闭进程的内核线程。那么线程结束之后和下一个定时器中断之间这段时间，CPU仍然会被这个线程占有吗？还是说我们在结束线程的时候会启动一个新的线程？
>
> Robert教授：exit系统调用会出让CPU。尽管我们这节课主要是基于定时器中断来讨论，但是实际上XV6切换线程的绝大部分场景都不是因为定时器中断，比如说一些系统调用在等待一些事件并决定让出CPU。exit系统调用会做各种操作然后调用yield函数来出让CPU，这里的出让并不依赖定时器中断。

## XV6线程切换 --- yield/sched函数

回到usertrap中，我们走到yield函数。 这是线程切换的第一步。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

它只改变了当前进程的状态然后就调用了sched函数。注意这里状态改变需要加锁，保证正确性。

sched函数位于proc.c

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

这个函数没干什么事情，做了一些合理性检查，然后调用swtch函数。

swtch函数是一个偏向汇编的函数，因为它涉及到很多对寄存器的操作。它首先需要将当前内核线程的寄存器信息保存到p->context中，swtch函数第二个参数是c->context,就是cpu的context，保存scheduler的context，接下来就会恢复scheduler的线程。

这里我们看一下scheduler context中RA字段的内容。 这告诉我们要返回的函数是scheduler函数。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

swtch函数的工作基本上就是保存context，加载另一个context。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

之后函数就返回了，根据RA地址，返回的是scheduler函数。

这里有个很有意思的问题，为什么保存的context字段中没PC？

因为PC不管怎样都会随着函数调用而更新。它无法提供有效信息，我们关心的是从哪里调用进入swtch的。因此RA 寄存器游泳。

现在执行完成后，我们已经在调度器线程中了。虽然我们还在swtch中，但我们实际上位于上一次程序调用的swtch中。因为schedule线程启动是也是调用的swtch函数。接下来执行ret就能返回到调度器线程中。

> 
>
> 学生提问：我不知道我们使用的RISC-V处理器是不是有一些其他的状态？但是我知道一些Intel的X86芯片有floating point unit state等其他的状态，我们需要处理这些状态吗？
>
> Robert教授：你的观点非常对。在一些其他处理器例如X86中，线程切换的细节略有不同，因为不同的处理器有不同的状态。所以我们这里介绍的代码非常依赖RISC-V。其他处理器的线程切换流程可能看起来会非常的不一样，比如说可能要保存floating point寄存器。我不知道RISC-V如何处理浮点数，但是XV6内核并没有使用浮点数，所以不必担心。但是是的，线程切换与处理器非常相关。
>
> 学生提问：为什么swtch函数要用汇编来实现，而不是C语言？
>
> Robert教授：C语言中很难与寄存器交互。可以肯定的是C语言中没有方法能更改sp、ra寄存器。所以在普通的C语言中很难完成寄存器的存储和加载，唯一的方法就是在C中嵌套汇编语言。所以我们也可以在C函数中内嵌switch中的指令，但是这跟我们直接定义一个汇编函数是一样的。或者说swtch函数中的操作是在C语言的层级之下，所以并不能使用C语言。

## XV6线程切换 --- scheduler函数

当我们进入scheduler线程中，会遇到scheduler函数。

注释上说，scheduler函数不会停止，永远循环，每次选择一个进程执行，等待它切换控制权，还给scheduler。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

看这个代码就能发现，我们进入了一个死循环，而每次找到一个可执行进程来执行。当一个进程执行结束被定时器中断后，会返回到这个函数中，此时我们设置c->proc =0 ,因为这段时间后没有process在运行。在这段过程中需要加锁，因为我们希望对于进程状态的所有设置都是原子性的。

这里的swtch函数就能让我们切换到另一个内核线程来执行了。而我们知道另一个内核线程之前也是经过线程切换的，因此此时swtch会返回到sched函数。

为可以预期的是，将要切换到的进程之前是被定时器中断通过sched函数挂起的，并且之前在sched函数中又调用了swtch函数。

当你打印backtrace时，就能发现一样的函数调用，

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

> 学生提问：如果不是因为定时器中断发生的切换，我们是不是可以期望ra寄存器指向其他位置，例如sleep函数？
>
> Robert教授：是的，我们之前看到了代码执行到这里会包含一些系统调用相关的函数。你基本上回答了自己的问题，如果我们因为定时器中断之外的原因而停止了执行当前的进程，switch会返回到一些系统调用的代码中，而不是我们这里看到sched函数。我记得sleep最后也调用了sched函数，虽然bracktrace可能看起来会不一样，但是还是会包含sched。所以我这里只介绍了一种进程间切换的方法，也就是因为定时器中断而发生切换。但是还有其他的可能会触发进程切换，例如等待I/O或者等待另一个进程向pipe写数据。

注意swtch是线程切换的核心，但它只保存和恢复寄存器的内容。还有很多线程运行中的数据是直接存在内存中的，他们在线程切换过程中不会丢失或者修改。所以不用特意保存并恢复。我们只是保存并恢复了处理器中的寄存器，因为我们想在新的线程中也使用相同的一组寄存器。

## XV6线程第一次调用switch函数

在之前我们假设每一个线程在上一次都是通过swtch函数切换的进程。 但这对进程的第一次调用来说不成立。因此我们需要伪造一些信息来保证他符合这种情况。

> 学生提问：操作系统都带了线程的实现，如果想要在多个CPU上运行一个进程内的多个线程，那需要通过操作系统来处理而不是用户空间代码，是吧？那这里的线程切换是怎么工作的？是每个线程都与进程一样了吗？操作系统还会遍历所有存在的线程吗？比如说我们有8个核，每个CPU核都会在多个进程的更多个线程之间切换。同时我们也不想只在一个CPU核上切换一个进程的多个线程，是吧？
>
> Robert教授：Linux是支持一个进程包含多个线程，Linux的实现比较复杂，或许最简单的解释方式是：几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。
>
> 学生提问：用户可以指定将线程绑定在某个CPU上吗？操作系统如何确保一个进程的多个线程不会运行在同一个CPU核上？要不然就违背了多线程的初衷了。
>
> Robert教授：这里其实与XV6非常相似，假设有4个CPU核，Linux会找到4件事情运行在这4个核上。如果并没有太多正在运行的程序的话，或许会将一个进程的4个线程运行在4个核上。或者如果有100个用户登录在Athena机器上，内核会随机为每个CPU核找到一些事情做。
>
> 如果你想做一些精细的测试，有一些方法可以将线程绑定在CPU核上，但正常情况下人们不会这么做。
>
> 学生提问：所以说一个进程中的多个线程会有相同的page table？
>
> Robert教授：是的，如果你在Linux上，你为一个进程创建了2个线程，我不确定它们是不是共享同一个的page table，还是说它们是不同的page table，但是内容是相同的。
>
> 学生提问：有没有原因说这里的page table要是分开的？
>
> Robert教授：我不知道Linux究竟用了哪种方法。

（注，以下是线程第一次调用switch的过程）

> 学生提问：当调用swtch函数的时候，实际上是从一个线程对于switch的调用切换到了另一个线程对于switch的调用。所以线程第一次调用swtch函数时，需要伪造一个“另一个线程”对于switch的调用，是吧？因为也不能通过swtch函数随机跳到其他代码去。
>
> Robert教授：是的。我们来看一下第一次调用switch时，“另一个”调用swtch函数的线程的context对象。proc.c文件中的allocproc函数会被启动时的第一个进程和fork调用，allocproc会设置好新进程的context，如下所示：

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

> 实际上大部分寄存器的内容都无所谓。但是ra很重要，因为这是进程的第一个switch调用会返回的位置。同时因为进程需要有自己的栈，所以ra和sp都被设置了。这里设置的forkret函数就是进程的第一次调用swtch函数会切换到的“另一个”线程位置。
>
> 学生提问：所以当swtch函数返回时，CPU会执行forkret中的指令，就像forkret刚刚调用了swtch函数并且返回了一样？
>
> Robert教授：是的，从switch返回就直接跳到了forkret的最开始位置。
>
> 学生提问：因吹斯听，我们会在其他场合调用forkret吗？还是说它只会用在这？
>
> Robert教授：是的，它只会在启动进程的时候以这种奇怪的方式运行。下面是forkret函数的代码，

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

> 从代码中看，它的工作其实就是释放调度器之前获取的锁。函数最后的usertrapret函数其实也是一个假的函数，它会使得程序表现的看起来像是从trap中返回，但是对应的trapframe其实也是假的，这样才能跳到用户的第一个指令中。
>
> 学生提问：与之前的context对象类似的是，对于trapframe也不用初始化任何寄存器，因为我们要去的是程序的最开始，所以不需要做任何假设，对吧？
>
> Robert教授：我认为程序计数器还是要被初始化为0的。

![img](Lec11%20%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E6%A6%82%E8%BF%B0.assets/image.png)

> 因为fork拷贝的进程会同时拷贝父进程的程序计数器，所以我们唯一不是通过fork创建进程的场景就是创建第一个进程的时候。这时需要设置程序计数器为0。
>
> 学生提问：在fortret函数中，if(first)是什么意思？
>
> Robert教授：文件系统需要被初始化，具体来说，需要从磁盘读取一些数据来确保文件系统的运行，比如说文件系统究竟有多大，各种各样的东西在文件系统的哪个位置，同时还需要有crash recovery log。完成任何文件系统的操作都需要等待磁盘操作结束，但是XV6只能在进程的context下执行文件系统操作，比如等待I/O。所以初始化文件系统需要等到我们有了一个进程才能进行。而这一步是在第一次调用forkret时完成的，所以在forkret中才有了if(first)判断。