# Lec13 Sleep & Wake up (Robert)

这个lecture我们会首先重温上线程切换的内容，之后我们会讨论coordination。 xv6通过sleep and wakeup来实现coordination。 最后会介绍lost wakeup问题。

之前我们介绍过，在xv6中调用swtch函数都会从一个线程切换到另一个线程。在调用swtch函数前，总是会先获取线程对应用户进程的锁。这个过程是：一个线程先获取自己的锁，再切换到调度器线程，调度器线程再释放进程的锁。 因为swtch切换进程时需要对context这一共享资源进行保存，所以要加锁保证这个数据保存时不被修改。

实际上代码顺序如下：

1. 一个进程处于某些原因要出让CPU，比如定时器中断或者sleep等待某些数据。

2. 这个进程会获取自己的锁。
3. 将自己的状态从running改为runable
4. 调用sched函数，在shced中调用swtch函数，切换调度器线程。
5. 调度器线程从swtch函数返回，释放刚刚出让CPU的进程的锁。

如果这个进程不加锁的话，在running改为runable过程就会出现问题。如果你的计算机是多核的，当这个进程的状态改为runable后，在另外一个CPU上立马发现它是runable，就会执行这个进程。而两个CPU同时使用一个stack，会使得系统立即崩溃。

所以我们需要在状态修改前加上锁并且在切换调度器线程完成后再释放。此时，这个进程就可以被其他CPU运行了。

这是线程切换中非常重要的细节。这是sleep and wakeup设计中众多限制条件之一。 对于在线程切换过程中需要一直持有p->lock.

> 学生提问：当我们有多个CPU核时，它们能看到同样的锁对象的唯一原因只可能是它们有一个共享的物理内存系统，对吧？
>
> Robert教授：是的。如果你有两个电脑，那么它们不会共享内存，并且我们就不会有这些问题。现在的处理器上，总是有多个CPU核，它们共享了相同的内存系统。

还有一个细节，在xv6中，不允许进程在执行swtch函数过程中持有任何其他的锁，必须也只能持有进程的锁。这也是包含了sleep在内的很多设计的限制条件之一。如果你是一个xv6程序员，你需要遵守这一规则。原因入下。假设我们加上了其他的锁，这些锁可能是设备带来的，UART等。进程切换后，p1仍然设备的锁，可P1不在运行，所以无法release这个锁。这导致其他线程无法获取设备的锁，造成死锁问题。假设这里是spinlock，那么另外那个进程在一个死循环里等待锁被释放。

> 学生提问：难道定时器中断不会将CPU控制切换回进程P1从而解决死锁的问题吗？
>
> Robert教授：首先，所有的进程切换过程都发生在内核中，所有的acquire，switch，release都发生在内核代码而不是用户代码。实际上XV6允许在执行内核代码时触发中断，如果你查看trap.c中的代码你可以发现，如果XV6正在执行内核代码时发生了定时器中断，中断处理程序会调用yield函数并出让CPU。
>
> 但是在之前的课程中我们讲过acquire函数在等待锁之前会关闭中断，否则的话可能会引起死锁（注，详见10.8），所以我们不能在等待锁的时候处理中断。所以如果你查看XV6中的acquire函数，你可以发现函数中第一件事情就是关闭中断，之后再“自旋”等待锁释放。你或许会想，为什么不能先“自旋”等待锁释放，再关闭中断？因为这样会有一个短暂的时间段锁被持有了但是中断没有关闭，在这个时间段内的设备的中断处理程序可能会引起死锁。
>
> 所以不幸的是，当我们在自旋等待锁释放时会关闭中断，进而阻止了定时器中断并且阻止了进程P2将CPU出让回给进程P1。嗯，这是个好问题。
>
> 学生提问：能重复一下死锁是如何避免的吗？
>
> Robert教授：哦，在XV6中，死锁是通过禁止在线程切换的时候加锁来避免的。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

> XV6禁止在调用switch函数时，获取除了p->lock以外的其他锁。如果你查看sched函数的代码（注，详见11.6），里面包含了一些检查代码来确保除了p->lock以外线程不持有其他锁。所以上面会产生死锁的代码在XV6中是不合法的并被禁止的。

将这里描述的对于锁的两个限制条件（加锁，只能加进程的锁）记住，因为我们后面讨论Sleep&Wakeup如何工作时会再次使用它们。

## Sleep and Wakeup接口

接下来看如何通过 sleep&Wakeup实现coordination。

考虑以下情景：

1. 假设我们有一个pipe，并且我们正在pipe中读取数据，但当前没有可读取数据，所以我们需要等待pipe非空的时间。
2. 类似的，我们在读取磁盘，我会告诉磁盘我们读取特定块上的数据，这需要花费很多时间，这时候我们需要等待。
3. 还有，一个unix进程可以调用wait函数，这会使得调用进程等待任何一个子进程退出。所以这里父进程在有意的等待另一个进程产生的事件。

以下就是进程需要等待的一些例子，可能是因为I/O，可能是另外一个进程。coordination是解决这些等待问题的基础工具。

我们怎么能让进程或线程等待一些特定的事件呢？

一个简单的方法是busy-wait，我们一直循环，等待buffer不为空。这样看起来很笨，但实际上是有这样的代码的。 如果你的事件发生的频率很小，这样做或许效率更高。

另外一种复杂的方式发生在，如果你不知道事件需要多久才能发生，我们不希望一直在这循环等待，浪费CPU资源。 我们希望通过swtch切换到其他进程来工作。coordination就是有关出让CPU，直到等待的事件发生再恢复执行。 人民发明了很多coordination的实现方式，今天介绍经典的 sleep & Wakeup。

接下来看看uart的代码，这里xv6通过驱动代码从console中读写字符。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

当shell需要输出时会调用write syscall 最终走到uartwrite函数。 首先要获取设备uart的锁，因为这时我们在读取它buffer里的内容，我们不希望有人在中途修改buffer。 然后每次send 一个 character。 这个函数会在循环中将buf中的字符一个一个的向uart中发送。这时经典的设备驱动实现风格。 uart一次只接受一个字符的传输，而通常来说会有很多字符需要写到uart硬件上。 你可以向UART硬件写入一个字符，并等待UART硬件说：我传输好了，并准备好传输下一个字符。 之后驱动程序才可以写入下个字符。 因为这里硬件可能会非常慢，在这个周期内CPU可以执行几百万条指令，我们不能等待这一过程。我们不想通过循环来等待UART完成字符传输，我们想通过一个更好的方式来等待。如大多数操作系统一样，XV6也的确存在更好的等待方式。

uart传输完一个字符后会触发一个中断，所以UART驱动中除了uartwrite函数外，还有uartintr函数来处理中断，这个函数会在硬件中断触发时由trap.c代码调用。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

中断处理首先会设置tx_done =1 ,然后再wakeup uart。这个函数会使得sleep函数恢复执行，并尝试发送一个新的字符。

所以这里的机制是，如果一个线程需要等待某些事件，比如等待UART硬件愿意接受一个新的字符，线程会调用sleep并等待一个特定条件。之后中断会响应， 设置特定条件，然后调用wakeup，继续传输下一个字符。这里的sleep函数和wakeup函数是成对出现的。 我们之后会看sleep的具体实现，但核心是它调用了swtch来切换线程，让出CPU资源。

这里你会发现，sleep和wake是通过第一个参数连接起来的。 wakeup需要知道它要唤醒哪个线程。 这个参数是sleep channel。

我们在调用wakeup的时候，需要传入与调用sleep函数相同的sleep channel。不过sleep和wakeup函数只是接收表示了sleep channel的64bit数值，它们并不关心这个数值代表什么。当我们调用sleep函数时，我们通过一个sleep channel表明我们等待的特定事件，当调用wakeup时我们希望能传入相同的数值来表明想唤醒哪个线程。

> 学生提问：进程会在写入每个字符时候都被唤醒一次吗？
>
> Robert教授：在这个我出于演示目的而特别改过的UART驱动中，传输每个字符都会有一个中断，所以你是对的，对于buffer中的每个字符，我们都会等待UART可以接收下一个字符，之后写入一个字符，将tx_done设置为0，回到循环的最开始并再次调用sleep函数进行睡眠状态，直到tx_done为1。当UART传输完了这个字符，uartintr函数会将tx_done设置为1，并唤醒uartwrite所在的线程。所以对于每个字符都有调用一次sleep和wakeup，并占用一次循环。
>
> UART实际上支持一次传输4或者16个字符，所以一个更有效的驱动会在每一次循环都传输16个字符给UART，并且中断也是每16个字符触发一次。更高速的设备，例如以太网卡通常会更多个字节触发一次中断。

以上是接口的演示。可以看到sleep &wakeup十分灵活。但我们还没有介绍第二个参数，这是一个锁，是个非常重要的参数，如果没有会出现lost wakeup的情况。然而加上这个参数后就破坏了函数设计的抽象性。我们无法设计一个sleep函数完全忽略需要等待的事件，所以很难写一个通用的sleep函数。

## Lost Wakeup

在解释为什么要有锁这个参数之前，我们先假设我们有了一个更简单的不带锁的sleep函数，会出现什么样的结果？

假设sleep函数只有sleep_channel这个参数，它其实无法正常工作，我们称它为broken_sleep. 你可以想象一下一个sleep函数会将进程状态设置为sleep表示这个进程当前不想运行，在等待一个特定时间。 

sleep的工作是：

记录特定的sleep_channel的值，以便之后wakeup调用时能够发现是对应的线程。最后调用swtch切换线程。

除了这些，还需要获取进程的锁。因为这里涉及到修改进程状态。

而wakeup的工作是：唤醒等待的sleep channel对应的线程。

具体地，wakeup会查询表单中的所有进程，如果有进程是sleep并且sleep_channel对应上，那么将进程状态设置为runable。



在一些平行宇宙中，sleep&wakeup或许就是这么简单。在我回到XV6代码之前，让我演示一下如何在UART驱动中使用刚刚介绍的sleep和wakeup函数。这基本上是重复前一节的内容，不过这次我们使用刚刚介绍的稍微简单的接口。

首先是定义done标志位。之后是定义uartwrite函数。在函数中，对于buffer内的每一个字符，检查done标志位，如果标志位为0，就调用sleep函数并传入tx_channel。之后将字符传递给UART并将done设置为0。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

之后是中断处理函数uartintr。函数中首先将done标志位设置为1，并调用wakeup。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

以上就是使用broken_sleep的方式。这里缺失的是锁。这里uartwrite和uartintr两个函数需要使用锁来协调工作。

1. 第一是因为这里设计到对done标志位的修改，这是shared data，需要上锁。
2. 第二是两个函数（write，intr）都可能同时访问uart硬件，这是不允许的。通常来说让两个线程并发的访问memory mapped register是错误的行为。

所以我们需要在两个函数中加锁来避免对done标志位和硬件资源的竞争。

问题是，在哪里加锁？

对于中断处理程序来说，这比较简单，我们在最开始加锁，最后解锁。

可是在uartwrite中也这样做，每次遍历的开始和结束加锁解锁，会发生什么？

只能发送一个字符，之后就会出现死锁，困在loop中出不来了。

这是因为，如果每次loop我们都加上锁，done标志位就无法被中断处理程序修改。中断程序会进入spinlock，等着uartwrite释放锁。而uartwrite只会在done标志位被设置为1时才能release lock。

上面加锁方式的问题是，中断处理程序执行时数据被其他线程上锁。 而我们唯一期望的是中断处理程序执行的位置是sleep函数执行期间。其他时间uartwrite持有锁是没有问题的。那么，我们可以在最开始上锁，在sleep函数执行前release锁，然后sleep执行后再加上锁。

代码就变成了这样。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

编译代码后，1你会发现，在XV6启动的时候会打印“init starting”，这里看来输出了一些字符之后就hang住了。如果我输入任意字符，剩下的字符就能输出。这里发生了什么？

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

这是因为，在release lock和 调用broken sleep之间，也可能出现中断，在这个时间中断发生，uartintr处理中断，而此时uartwrite线程状态还是runable，无法wakeup这个线程。

之后broken_sleep会继续运行，而wakeup已经运行过了。这就是lost wakeup的问题。

一旦释放了锁，当前CPU的中断会被重新打开。因为这是一个多核机器，所以中断可能发生在任意一个CPU核。在上面代码标记的位置，其他CPU核上正在执行UART的中断处理程序，并且正在acquire函数中等待当前锁释放。所以一旦锁被释放了，另一个CPU核就会获取锁，并发现UART硬件完成了发送上一个字符，之后会设置tx_done为1，最后再调用wakeup函数，并传入tx_chan。目前为止一切都还好，除了一点：现在写线程还在执行并位于release和broken_sleep之间，也就是写线程还没有进入SLEEPING状态，所以中断处理程序中的wakeup并没有唤醒任何进程，因为还没有任何进程在tx_chan上睡眠。之后写线程会继续运行，调用broken_sleep，将进程状态设置为SLEEPING，保存sleep channel。但是中断已经发生了，wakeup也已经被调用了。所以这次的broken_sleep，没有人会唤醒它，因为wakeup已经发生过了。这就是lost wakeup问题。

> 学生提问：是不是总是这样，一旦一个wakeup被丢失了，下一次wakeup时，之前缓存的数据会继续输出？
>
> Robert教授：这完全取决于实现细节。在我们的例子中，实际上出于偶然才会出现当我输入某些内容会导致之前的输出继续的现象。这里背后的原因是，我们的代码中，UART只有一个中断处理程序。不论是有输入，还是完成了一次输出，都会调用到同一个中断处理程序中。所以当我输入某些内容时，会触发输入中断，之后会调用uartintr函数。然后在中断处理程序中又会判断LSR_TX_IDLE标志位，并再次调用wakeup，所以刚刚的现象完全是偶然。如果出现了lost wakeup问题，并且你足够幸运的话，某些时候它们能自动修复。如果UART有不同的接收和发送中断处理程序的话，那么就没办法从lost wakeup恢复。
>
> 学生提问：tx_done标志位的作用是什么？
>
> Robert教授：这是一种简单的在uartintr和uartwrite函数之间通信的方法。tx_done标志位为1表示已经完成了对于前一个字符的传输，并且uartwrite可以传输下一个字符，所以这是用来在中断处理程序和uartwrite之间通信的标志位。
>
> 同一个学生提问：当从sleep函数中唤醒时，不是已经知道是来自UART的中断处理程序调用wakeup的结果吗？这样的话tx_done有些多余。
>
> Robert教授：我想你的问题也可以描述为：为什么需要通过一个循环while(tx_done == 0)来调用sleep函数？这个问题的答案适用于一个更通用的场景：实际中不太可能将sleep和wakeup精确匹配。并不是说sleep函数返回了，你等待的事件就一定会发生。举个例子，假设我们有两个进程同时想写UART，它们都在uartwrite函数中。可能发生这种场景，当一个进程写完一个字符之后，会进入SLEEPING状态并释放锁，而另一个进程可以在这时进入到循环并等待UART空闲下来。之后两个进程都进入到SLEEPING状态，当发生中断时UART可以再次接收一个字符，两个进程都会被唤醒，但是只有一个进程应该写入字符，所以我们才需要在sleep外面包一层while循环。实际上，你可以在XV6中的每一个sleep函数调用都被一个while循环包着。因为事实是，你或许被唤醒了，但是其他人将你等待的事件拿走了，所以你还得继续sleep。这种现象还挺普遍的。
>
> 学生提问：我们只看到了一个lost wakeup，当我们随便输入一个字符，整个剩下的字符都能输出，为什么没有在输出剩下字符的时候再次发生lost wakeup？
>
> Robert教授：这会发生的。我来敲一下cat README，这会输出数千个字符。可以看到每过几个字符就会hang一次，需要我再次输入某个字符。这个过程我们可以看到很多lost wakeup。之前之所以没有出现，是因为lost wakeup需要中断已经在等待获取锁，并且uartwrite位于release和broken_sleep之间，这需要一定的巧合并不总是会发生。

## 如何避免Lost wakeup

避免lost wakeup，就只需要消除release lock 和 sleep 之间的窗口时间。

这可以在sleep函数中release lock来实现。 因此我们需要传入一个锁。这会复杂化sleep函数，使得sleep函数很丑陋。

在sleep函数中先对进程加锁（使得进程状态字段无法被其他函数获取），再release 设备的lock。

就算窗口期有中断发生，中断处理函数也无法获知进程当前的状态。需要等待进程锁的释放。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

为了实现这个目的，我们需要将sleep函数设计的稍微复杂点。这里的解决方法是，即使sleep函数不需要知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。sleep函数需要特定的条件才能执行，而sleep自己又不需要知道这个条件是什么。在我们的例子中，sleep函数执行的特定条件是tx_done等于1。虽然sleep不需要知道tx_done，但是它需要知道保护这个条件的锁，也就是这里的uart_tx_lock。在调用sleep的时候，锁还被当前线程持有，之后这个锁被传递给了sleep。

在接口层面，sleep承诺可以原子性的将进程设置成SLEEPING状态，同时释放锁。这样wakeup就不可能看到这样的场景：锁被释放了但是进程还没有进入到SLEEPING状态。所以sleep这里将释放锁和设置进程为SLEEPING状态这两个行为合并为一个原子操作。

所以我们需要有一个锁来保护sleep的条件，并且这个锁需要传递给sleep作为参数。更进一步的是，当调用wakeup时，锁必须被持有。如果程序员想要写出正确的代码，都必须遵守这些规则来使用sleep和wakeup。

接下来我们看一下sleep和wakeup如何使用这一小块额外的信息（注，也就是传入给sleep函数的锁）和刚刚提到的规则，来避免lost wakeup。

首先我们来看一下proc.c中的wakeup函数。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

wakeup函数并不十分出人意料。它查看整个进程表单，对于每个进程首先加锁，这点很重要。之后查看进程的状态，如果进程当前是SLEEPING并且进程的channel与wakeup传入的channel相同，将进程的状态设置为RUNNABLE。最后再释放进程的锁。

接下来我们忽略broken_sleep，直接查看带有锁作为参数的sleep函数。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

我们已经知道了sleep函数需要释放作为第二个参数传入的锁，这样中断处理程序才能获取锁。函数中第一件事情就是释放这个锁。当然在释放锁之后，我们会担心在这个时间点相应的wakeup会被调用并尝试唤醒当前进程，而当前进程还没有进入到SLEEPING状态。所以我们不能让wakeup在release锁之后执行。为了让它不在release锁之后执行，在release锁之前，sleep会获取即将进入SLEEPING状态的进程的锁。

如果你还记得的话，wakeup在唤醒一个进程前，需要先获取进程的锁。所以在整个时间uartwrite检查条件之前到sleep函数中调用sched函数之间，这个线程一直持有了保护sleep条件的锁或者p->lock。让我回到UART的代码并强调一下这一点。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

uartwrite在最开始获取了sleep的condition lock，并且一直持有condition lock直到调用sleep函数。所以它首先获取了condition lock，之后检查condition（注，也就是tx_done等于0），之后在持有condition lock的前提下调用了sleep函数。此时wakeup不能做任何事情，wakeup现在甚至都不能被调用直到调用者能持有condition lock。所以现在wakeup必然还没有执行。

sleep函数在释放condition lock之前，先获取了进程的锁。在释放了condition lock之后，wakeup就可以被调用了，但是除非wakeup获取了进程的锁，否则wakeup不能查看进程的状态。所以，在sleep函数中释放了condition lock之后，wakeup也还没有执行。

在持有进程锁的时候，将进程的状态设置为SLEEPING并记录sleep channel，之后再调用sched函数，这个函数中会再调用switch函数（注，详见11.6），此时sleep函数中仍然持有了进程的锁，wakeup仍然不能做任何事情。

如果你还记得的话，当我们从当前线程切换走时，调度器线程中会释放前一个进程的锁（注，详见11.8）。所以在调度器线程释放进程锁之后，wakeup才能终于获取进程的锁，发现它正在SLEEPING状态，并唤醒它。

这里的效果是由之前定义的一些规则确保的，这些规则包括了：

1. 调用sleep时需要知道condition lock
2. sleep函数只有获取了进程lock才能释放condition lock
3. wakeup需要同时持有两个锁才能查看进程。

这样的话，我们就不会再丢失任何一个wakeup，也就是说我们修复了lost wakeup的问题。

## Pipe中的sleep和wake up

之前我们介绍了在UART的驱动中如何使用sleep和wakeup，才能避免lost wakeup。在其他场景下，内核也会调用sleep函数来等待其他线程完成某些事情。这一节我们介绍pipe中的sleep和wake up。它们本质上来说没有区别，但有些微小的差异。

例如，在读写pipe的代码中，pipe.c中的piperead函数：

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

最上面，它用了一个while loop来判断，如果当前没用可读资源就是会sleep。

其次，sleep需要的锁就是pi->lock，这就是sleep函数对应的condition lock。

这里lost wakeup会发生的情况是：当另一个CPU也在运行piperead函数，在执行wakeup部分，而此时另一个CPU上还没运行到sleep函数，此时不存在sleep的线程且sleep_channel对应。 而这个wake up就miss掉了。

那个幸运的进程（注，这里线程和进程描述的有些乱，但是基本意思是一样的，当说到线程时是指进程唯一的内核线程）会从sleep函数中返回，之后通过检查可以发现pi->nwrite比pi->nread大1，所以进程可以从piperead的循环中退出，并读取一个字节，之后pipe缓存中就没有数据了。之后piperead函数释放锁并返回。接下来，第二个被唤醒的线程，它的sleep函数可以获取condition lock并返回，但是通过检查发现pi->nwrite等于pi->nread（注，因为唯一的字节已经被前一个进程读走了），所以这个线程以及其他所有的等待线程都会重新进入sleep函数。所以这里也可以看出，几乎所有对于sleep的调用都需要包装在一个循环中，这样从sleep中返回的时候才能够重新检查condition是否还符合。

sleep和wakeup的规则稍微有点复杂。因为你需要向sleep展示你正在等待什么数据，你需要传入锁并遵循一些规则，某些时候这些规则还挺烦人的。另一方面sleep和wakeup又足够灵活，因为它们并不需要理解对应的condition，只是需要有个condition和保护这个condition的锁。

除了sleep&wakeup之外，还有一些其他的更高级的Coordination实现方式。例如今天课程的阅读材料中的semaphore，它的接口就没有那么复杂，你不用告诉semaphore有关锁的信息。而semaphore的调用者也不需要担心lost wakeup的问题，在semaphore的内部实现中考虑了lost wakeup问题。因为定制了up-down计数器，所以semaphore可以在不向接口泄露数据的同时（注，也就是不需要向接口传递condition lock），处理lost wakeup问题。semaphore某种程度来说更简单，尽管它也没那么通用，如果你不是在等待一个计数器，semaphore也就没有那么有用了。这也就是为什么我说sleep和wakeup更通用的原因。

## exit系统调用

接下来我们讨论一下XV6面临的一个与sleep & wakeup相关的挑战-如何关闭一个进程。 所有进程最终都要被关闭。我们需要清楚进程的状态，释放栈。 具体地，释放用户内存，page table，trapframe，标记进程为REUSABLE。

这里有两个大问题：

1. 不能单方面直接摧毁一个线程，因为一个线程可能正在运行一些代码，或者持有一把锁。

2. 计算一个线程决定退出，它仍然持有一些资源比如stack，当他还在执行代码时，这些资源不能直接释放。我们需要一种方面让线程能释放最后几个对于运行代码来说关键的资源。

关闭进程有两个主要函数，exit和kill，先讨论位于proc.c的exit。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

首先，会关闭与这个进程相关的一些文件，然后处理一下cwd，当前文件夹。

如果当前进程有很多子进程，而自己又即将退出，，那么子进程就不再有父进程，当它们要退出时就没有对应的父进程的wait。那就将这些子进程全部re-parent到initproc，它的pid = 1，

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

之后，我们需要通过调用wakeup函数唤醒当前进程的父进程，当前进程的父进程或许正在等待当前进程退出。

接下来当前进程被设置状态为ZOMBIE，因为它还没有完全释放它的资源，所以它还不能被重用。 所谓的进程重用是指，进程能够被其他fork复用。

我们现在还没有结束，资源还没有被完全释放，此时调用sched进入调度器线程。

目前为止，进程状态时ZOMBIE且不可能会被调度器线程切换到。

> 学生提问：在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？
>
> Robert教授：这里其实就是在防止一个进程和它的父进程同时退出。通常情况下，一个进程exit，它的父进程正在wait，一切都正常。但是也可能一个进程和它的父进程同时exit。所以当子进程尝试唤醒父进程，并告诉它自己退出了时，父进程也在退出。这些代码我一年前还记得是干嘛的，现在已经记不太清了。它应该是处理这种父进程和子进程同时退出的情况。如果不是这种情况的话，一切都会非常直观，子进程会在后面通过wakeup函数唤醒父进程。

## wait系统调用

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

wait的功能是，如果一个子进程exit了，且他的父进程调用了wait，那么父进程的wait会返回，父进程会知道它的子进程返回了。

代码很简单，它有一个死循环，扫描它的子进程，找到一个zombie进程，说明是exit的进程，然后调用freeproc清除子进程的内容。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

在freeproc中，就是清楚trapframe，pagetable等process的一些字段。

注意这里不打算clear out stack。

如果我们需要释放进程内核栈，那么也应该在这里释放。但是因为内核栈的guard page，我们没有必要再释放一次内核栈。不管怎样，当进程还在exit函数中运行时，**任何这些资源在exit函数中释放都会很难受**，所以这些资源都是由父进程释放的。

当完成清除工作后，进程状态就会变成UNUSED了。

强调，这里exit没有清楚它当前进程的内存数据，因为调用exit时自己还在运行，不能清除自己的内容。而是把这部分工作交给父进程的wait，这极大精简了exit的实现。

> 学生提问：为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？难道我们不应该在之前就设置吗？
>
> Robert教授：正在退出的进程会先获取自己进程的锁，同时，因为父进程的wait系统调用中也需要获取子进程的锁，所以父进程并不能查看正在执行exit函数的进程的状态。这意味着，正在退出的进程获取自己的锁到它调用sched进入到调度器线程之间（注，因为调度器线程会释放进程的锁），父进程并不能看到这之间代码引起的中间状态。所以这之间的代码顺序并不重要。大部分时候，如果没有持有锁，exit中任何代码顺序都不能工作。因为有了锁，代码的顺序就不再重要，因为父进程也看不到进程状态。
>
> 顺序不重要，因为有lock。

## Kill

最后来介绍一下kill。kill能直接杀死一个进程。但这样很危险，如果我们直接杀死一个正在运行一些代码的进程，可能它正在更新文件，此时就会造成一些数据的错乱。因此我们不能直接杀死进程。实际在unix系统中，kill基本上没做任何事，只是设置了一下进程的状态。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

它先扫描进程表单，找到目标进程。然后只是将进程的proc结构体中killed标志位设置为1。如果进程正在SLEEPING状态，将其设置为RUNNABLE。这里只是将killed标志位设置为1，并没有停止进程的运行。所以kill系统调用本身还是很温和的。

当你调用kill sys call，什么也不会发生，进程会照常运行。

当目标进程运行到内核代码能安全停止的位置，也就是在trap代码中，当它发现有进程的killed为1时，就会将它退出掉。



![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

所以kill不会真正杀死一个进程，而是标记它为可以杀死，等到在安全的地方再把他杀死。比如定时器触发，或者其他中断触发。所以从一个进程调用kill，到另一个进程真正退出，中间可能有很明显的延时。

在usertrap函数中（注，详见6.6），在执行系统调用之前，如果进程已经被kill了，进程会自己调用exit。在这个内核代码位置，代码并没有持有任何锁，也不在执行任何操作的过程中，所以进程通过exit退出是完全安全的。

类似的，在usertrap函数的最后，也有类似的代码。在执行完系统调用之后，进程会再次检查自己是否已经被kill了。即使进程是被中断打断，这里的检查也会被执行。例如当一个定时器中断打断了进程的运行，我们可以通过检查发现进程是killed状态，之后进程会调用exit退出。

还有一个问题：如果进程不在用户空间执行而是在执行系统调用，然后被kill了，我们需要做什么么？这是因为在进程中，很有可能因为设备原因，进程sleep了很久，可能几个小时，当你要kill这样的设备，最好不要等这么久。处于这个原因，如果进程在sleep时被kill，进程会立马退出。

看kill函数，如果它发现进程是sleep状态就会改成runable。wakeup 这个process。调度器会重新运行这个线程，并且从sleep中返回。

比如说之间的piperead函数中，sleep返回后就会立马判断这个process是否被kill，如果是，就piperead就退出。

因此，对于很可能sleep的代码，就需要判断它被kill的情况。

当然还有一些情况，你觉得我们需要sleep状态中被kill了不能直接退出。比如说你在创建一个文件，进程不适合sleep后里面退出，需要等到完全创建完成再退出。这时就取消检查进程killed标准。

这里一个进程正在等待磁盘的读取结束，这里没有检查进程的killed标志位。因为现在可能正在创建文件的过程中，而这个过程涉及到多次读写磁盘。我们希望完成所有的文件系统操作，完成整个系统调用，之后再检查p->killed并退出。

> 学生提问：为什么一个进程允许kill另一个进程？这样一个进程不是能杀掉所有其他进程吗？
>
> Robert教授：如果你在MIT的分时复用计算机Athena上这么做的话，他们可能会开除你。在XV6中允许这么做是因为，XV6这是个教学用的操作系统，任何与权限相关的内容在XV6中都不存在。在Linux或者真正的操作系统中，每个进程都有一个user id或多或少的对应了执行进程的用户，一些系统调用使用进程的user id来检查进程允许做的操作。所以在Linux中会有额外的检查，调用kill的进程必须与被kill的进程有相同的user id，否则的话，kill操作不被允许。所以，在一个分时复用的计算机上，我们会有多个用户，我们不会想要用户kill其他人的进程，这样一套机制可以防止用户误删别人的进程。
>
> 学生提问：init进程会退出吗？
>
> Robert教授：让我来看看。

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

> 是的，如果fork失败了，init进程也会退出。不过，这个问题的真正的答案是，不会退出。init进程的目标就是不退出，它就是在一个循环中不停的调用wait。如果init进程退出了，我认为这是一个Fatal级别的错误，然后系统会崩溃。在exit函数的最开始就会有如下检查

![img](Lec13%20Sleep%20And%20Wakeup.assets/image.png)

> 如果调用exit的进程是init进程，那么会触发panic。因为如果没有init进程的话，系统最终还是会停止运行。如果没有init进程的话就没有人会为退出的进程调用wait系统调用，也就没有人完成进程资源的释放工作，我们最终会用光所有的进程，并引起一些其他的错误，所以我们必须要有init进程。所以这个问题的真正答案是init进程不允许退出。
>
> 学生提问：这节课可能没有怎么讲到，但是如果关闭一个操作系统会发生什么？
>
> Robert教授：这个过程非常复杂，并且依赖于你运行的是什么系统。因为文件系统是持久化的，它能在多次重启之间保持数据，我们需要保持文件系统的良好状态，如果我们正在更新文件系统的过程中，例如创建文件，然后我们想关闭操作系统，断电之类的。我们需要一个策略来确保即使我们正在一个复杂的更新文件系统的过程中，我们并不会破坏磁盘上的文件系统数据。文件系统其实就是一个位于磁盘的数据结构。所以这里涉及到了很多的机制来确保如果你关闭操作系统或者因为断电之类，我们可以恢复磁盘上的文件系统。
>
> 其他的，你是否需要做一些特殊的操作来关闭系统，取决于你正在运行什么进程。如果你正在运行一些重要的服务器，例如数据库服务器，并且许多其他计算机依赖这个数据库并通过网络使用它。那谁知道呢？答案或许是你不能就这么直接关闭操作系统，因为你正在提供一个对于其他计算机来说非常关键的服务。
>
> 如果你的计算机并没有在做任何事情，那么你可以直接关闭它。或许对于你的问题来说，如果你想关闭一个计算机，确保文件系统是正确的，之后停止执行指令，之后就可以关闭计算机了。